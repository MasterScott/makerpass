#include <ESP8266WiFi.h>
//#include <ESP8266mDNS.h>
#include <ESP8266WebServer.h>

// Global server instance
ESP8266WebServer server (80);

// Global client instance
WiFiClient client;

// Forward declaration for index
extern const char index_html[];

// Buffer for URL decoding
char buf[200];

// Makerpass settings
String ssid, passwd, host, sid, format, msg;
int port;

// RFID variables
//
// Define wiegand format
#define WIEGAND_LEN  26

int onePin = 12;
int zeroPin = 14;

volatile unsigned char rfid_data[WIEGAND_LEN];
volatile int rfid_idx;

// Operating modes
enum opmode_t {
  MODE_CONFIGURATION,
  MODE_NORMAL,
  MODE_ENUM_MAX
};

// Global mode variable
enum opmode_t mode;

void setup() {

  // Setup serial
  Serial.begin (115200);

  // Setup AP
  WiFi.softAP ("Makerpass");

  // Setup mDNS to resolve makerpass.local
  //MDNS.begin ("makerpass");
  
  // Setup root
  server.on ("/", handle_root);

  // Setup cgi.bin handler
  server.on ("/cgi.bin", handle_cgi);
  
  // Start webserver
  server.begin ();

  // Start mDNS service
  //MDNS.addService ("http", "tcp", 80);

  // Set mode as configuration
  mode = MODE_CONFIGURATION;
}

void handle_root() {
  server.send(200, "text/html", index_html);
}

void handle_cgi (void)
{  
  // Loop through arguments
  for ( uint8_t i = 0; i < server.args(); i++ ) {
    if (server.argName(i).equals ("ssid")) {
      ssid = server.arg(i);
    }
    else if (server.argName(i).equals ("passwd")) {
      passwd = server.arg(i);
    }
    else if (server.argName(i).equals ("host")) {
      host = server.arg(i);
    }
    else if (server.argName(i).equals ("port")) {
      port = server.arg(i).toInt();
    }
    else if (server.argName(i).equals ("sid")) {
      sid = server.arg(i);
    }
    else if (server.argName(i).equals ("format")) {
      format = server.arg(i);
    }    
  }
  
  // Send success message
  server.send (200, "text/plain", "Configured, connecting to AP");

  // Debug format str
  Serial.println (format);

  // Decode format url to buf
  url_decode (buf, format.c_str());

  // Convert carriage returns and line feeds
  convert_crlf (buf, buf);

  // Convert to String
  msg = buf;

  // Replace static elements in msg
  msg.replace ("$sid", sid.c_str());
  msg.replace ("$host", host.c_str());

  // Reconfigure to connect to AP
  Serial.println (String ("Connecting to ") + ssid);
  WiFi.begin (ssid.c_str(), passwd.c_str());

  // Wait for connection
  while (WiFi.status () != WL_CONNECTED) {
    delay (500);
    Serial.print (".");
  }
  Serial.println ("");
  Serial.print ("Connected: ");
  Serial.println (WiFi.localIP ());

  // Reset index
  rfid_idx = 0;
  
  // Attach interrupts
  enableISR ();

  // Switch modes
  mode = MODE_NORMAL;
}

void url_decode (char *dst, const char *src)
{
  char a, b;
  while (*src) {
    if ((*src == '%') &&
      ((a = src[1]) && (b = src[2])) &&
      (isxdigit(a) && isxdigit(b))) {
      if (a >= 'a')
        a -= 'a'-'A';
      if (a >= 'A')
        a -= ('A' - 10);
      else
        a -= '0';
      if (b >= 'a')
        b -= 'a'-'A';
      if (b >= 'A')
        b -= ('A' - 10);
      else
        b -= '0';

      // Return when we hit carriage return
      if (16*a+b == '\r') {
        *dst++ = '\0';
        return;
      }
      *dst++ = 16*a+b;
      src+=3;
    }
    else {
      if (*src == '+') {
        *dst++ = ' ';
        src++;
      }
      else
        *dst++ = *src++;
    }
  }
  *dst++ = '\0';
}

void convert_crlf (char *dst, const char *src)
{
  while (*src) {

    // Check for escape sequences
    if (*src == '\\') {

      if (src[1] == 'r') {
        *dst++ = '\r';
        src += 2;
      }
      else if (src[1] == 'n') {
        *dst++ = '\n';
        src += 2;
      }
      else {
        *dst++ = *src++;
      }
    }
    else
      *dst++ = *src++;
  }
  *dst++ = '\0';
}

int decode_id (void)
{
  int i;
  unsigned char parity;
  unsigned int id = 0;
  
  // Start with parity bit
  parity = rfid_data[0];
  
  // Check parity
  for (i = 1; i < WIEGAND_LEN / 2; i++) {
    parity ^= rfid_data[i];
    id <<= 1;
    if (rfid_data[i])
      id |= 1;
  }
  
  // Check even parity
  if (parity)
    return -1;

  //Start with parity bit
  parity = rfid_data[WIEGAND_LEN - 1];

  for (i = WIEGAND_LEN / 2; i < WIEGAND_LEN - 1; i++) {
    parity ^= rfid_data[i];
    id <<= 1;
    if (rfid_data[i])
      id |= 1;
  }

  // Check odd parity
  if (parity == 0)
    return -1;
    
  return id;
}

void loop() {
  int id;

  if (mode == MODE_CONFIGURATION) {
    server.handleClient ();
  }
  else {
    if (rfid_idx == WIEGAND_LEN) {
  
      // Decode ID
      id = decode_id ();
      if (id == -1) {
        Serial.println ("Bad parity");
        delay (100);
        goto next_id;
      }
      else {
    
        // Print out to serial
        Serial.println (String ("User ID: ") + (id & 0xffff));
        
        // Make connection to host
        if (!client.connect (host.c_str(), port)) {
          Serial.println ("Failed to connect to host!");
          goto next_id;
        }

        // Replace dynamic data
        msg.replace ("$uid", String (id & 0xffff));
                      
        // Print message to send
        //Serial.println (msg);

        // Send id to host
        client.print (msg);
        delay (10);
  
        // Get Response
        /*
        while (client.available ()) {
          String line = client.readStringUntil ('\r');
          Serial.println (line);
        }
        */
      }
  
    next_id:
      // Reset index
      rfid_idx = 0;
  
      // Attach interrupts
      enableISR ();
    }
  }
}

void enableISR (void)
{
    // Set index to 0
  rfid_idx = 0;
  
  // Attach interrupt to pins
  attachInterrupt (zeroPin, data0, FALLING);
  attachInterrupt (onePin, data1, FALLING);
}

// ISR routines
void data0 (void)
{
  // Save bit
  rfid_data[rfid_idx++] = 0;

  // Detach ISRs when complete
  if (rfid_idx == WIEGAND_LEN) {
    detachInterrupt (zeroPin);
    detachInterrupt (onePin);
  }
}

void data1 (void)
{
  // Save bit
  rfid_data[rfid_idx++] = 1;

  // Detach ISRs when complete
  if (rfid_idx == WIEGAND_LEN) {
    detachInterrupt (zeroPin);
    detachInterrupt (onePin);
  }
}

// Root html configuration
const char index_html[] = {
  0x3c, 0x21, 0x44, 0x4f, 0x43, 0x54, 0x59, 0x50, 0x45, 0x20, 0x68, 0x74,
  0x6d, 0x6c, 0x3e, 0x0a, 0x3c, 0x68, 0x74, 0x6d, 0x6c, 0x3e, 0x0a, 0x3c,
  0x62, 0x6f, 0x64, 0x79, 0x3e, 0x0a, 0x3c, 0x68, 0x32, 0x3e, 0x4d, 0x61,
  0x6b, 0x65, 0x72, 0x70, 0x61, 0x73, 0x73, 0x20, 0x43, 0x6f, 0x6e, 0x66,
  0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3c, 0x2f, 0x68,
  0x31, 0x3e, 0x0a, 0x3c, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x61, 0x63, 0x74,
  0x69, 0x6f, 0x6e, 0x3d, 0x22, 0x63, 0x67, 0x69, 0x2e, 0x62, 0x69, 0x6e,
  0x22, 0x20, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x3d, 0x22, 0x47, 0x45,
  0x54, 0x22, 0x3e, 0x0a, 0x3c, 0x68, 0x33, 0x3e, 0x57, 0x69, 0x66, 0x69,
  0x20, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x3c,
  0x2f, 0x68, 0x33, 0x3e, 0x0a, 0x53, 0x53, 0x49, 0x44, 0x20, 0x3c, 0x69,
  0x6e, 0x70, 0x75, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3d, 0x22, 0x74,
  0x65, 0x78, 0x74, 0x22, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x3d, 0x22, 0x73,
  0x73, 0x69, 0x64, 0x22, 0x3e, 0x3c, 0x62, 0x72, 0x3e, 0x0a, 0x50, 0x61,
  0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x20, 0x3c, 0x69, 0x6e, 0x70, 0x75,
  0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x3d, 0x22, 0x74, 0x65, 0x78,
  0x74, 0x22, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x3d, 0x22, 0x70, 0x61, 0x73,
  0x73, 0x77, 0x64, 0x22, 0x3e, 0x3c, 0x62, 0x72, 0x3e, 0x0a, 0x3c, 0x68,
  0x33, 0x3e, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f,
  0x6e, 0x3c, 0x2f, 0x68, 0x33, 0x3e, 0x0a, 0x48, 0x6f, 0x73, 0x74, 0x20,
  0x3c, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20,
  0x3d, 0x22, 0x74, 0x65, 0x78, 0x74, 0x22, 0x20, 0x6e, 0x61, 0x6d, 0x65,
  0x3d, 0x22, 0x68, 0x6f, 0x73, 0x74, 0x22, 0x3e, 0x3c, 0x62, 0x72, 0x3e,
  0x0a, 0x50, 0x6f, 0x72, 0x74, 0x20, 0x3c, 0x69, 0x6e, 0x70, 0x75, 0x74,
  0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x3d, 0x22, 0x74, 0x65, 0x78, 0x74,
  0x22, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x3d, 0x22, 0x70, 0x6f, 0x72, 0x74,
  0x22, 0x3e, 0x3c, 0x62, 0x72, 0x3e, 0x0a, 0x3c, 0x68, 0x33, 0x3e, 0x50,
  0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x3c, 0x2f, 0x68, 0x33, 0x3e, 0x0a,
  0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x72, 0x20, 0x69, 0x64, 0x20, 0x3c,
  0x69, 0x6e, 0x70, 0x75, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3d, 0x22,
  0x74, 0x65, 0x78, 0x74, 0x22, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x3d, 0x22,
  0x73, 0x69, 0x64, 0x22, 0x3e, 0x3c, 0x62, 0x72, 0x3e, 0x0a, 0x3c, 0x74,
  0x65, 0x78, 0x74, 0x61, 0x72, 0x65, 0x61, 0x20, 0x6e, 0x61, 0x6d, 0x65,
  0x3d, 0x22, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x22, 0x20, 0x63, 0x6f,
  0x6c, 0x73, 0x3d, 0x22, 0x34, 0x30, 0x22, 0x20, 0x72, 0x6f, 0x77, 0x73,
  0x3d, 0x22, 0x36, 0x22, 0x20, 0x6d, 0x61, 0x78, 0x6c, 0x65, 0x6e, 0x67,
  0x74, 0x68, 0x3d, 0x22, 0x31, 0x39, 0x39, 0x22, 0x3e, 0x0a, 0x47, 0x45,
  0x54, 0x20, 0x2f, 0x63, 0x67, 0x69, 0x2d, 0x62, 0x69, 0x6e, 0x2f, 0x48,
  0x55, 0x44, 0x2e, 0x63, 0x67, 0x69, 0x3f, 0x73, 0x63, 0x61, 0x6e, 0x6e,
  0x65, 0x72, 0x5f, 0x69, 0x64, 0x3d, 0x24, 0x73, 0x69, 0x64, 0x26, 0x75,
  0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x3d, 0x24, 0x75, 0x69, 0x64, 0x20,
  0x48, 0x54, 0x54, 0x50, 0x2f, 0x31, 0x2e, 0x31, 0x5c, 0x72, 0x5c, 0x6e,
  0x48, 0x6f, 0x73, 0x74, 0x3a, 0x20, 0x24, 0x68, 0x6f, 0x73, 0x74, 0x5c,
  0x72, 0x5c, 0x6e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f,
  0x6e, 0x3a, 0x20, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x5c, 0x72, 0x5c, 0x6e,
  0x5c, 0x72, 0x5c, 0x6e, 0x0a, 0x3c, 0x2f, 0x74, 0x65, 0x78, 0x74, 0x61,
  0x72, 0x65, 0x61, 0x3e, 0x3c, 0x62, 0x72, 0x3e, 0x0a, 0x3c, 0x69, 0x6e,
  0x70, 0x75, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3d, 0x22, 0x73, 0x75,
  0x62, 0x6d, 0x69, 0x74, 0x22, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3d,
  0x22, 0x53, 0x61, 0x76, 0x65, 0x20, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e,
  0x67, 0x73, 0x22, 0x3e, 0x0a, 0x3c, 0x2f, 0x66, 0x6f, 0x72, 0x6d, 0x3e,
  0x0a, 0x3c, 0x2f, 0x62, 0x6f, 0x64, 0x79, 0x3e, 0x0a, 0x3c, 0x2f, 0x68,
  0x74, 0x6d, 0x6c, 0x3e, 0x0a
};
unsigned int index_html_len = 629;
